import schedule
import time
import json
import requests

import pandas as pd
import datetime as dt

from datetime import date, timedelta, datetime, tzinfo, timezone
from loguru import logger
from io import StringIO

from core.orchestrator import DataSourceConfig
from core.datacenter import DataCenterSrv
from core.algo_strat import AlgoStrategy
from strategy.strat_method import CreateSignal
from core.execution import SignalExecution


def gn_10m_status():
    dt_until = datetime.now(timezone.utc)
    unix_until = int(dt_until.timestamp())
    unix_since = unix_until - (60 * 60)

    hr_start_dt = dt_until.replace(minute=0, second=0, microsecond=0)
    unix_hr_start = int(hr_start_dt.timestamp())

    # Load API config once
    gn_api = DataSourceConfig.load_gn_api_config()
    gn_api_value: str = gn_api.get('GN_API')
    if not gn_api_value:
        logger.error('GN_API key not found in config.')
        return False

    # 0. Load strategy configuration
    ds = DataSourceConfig()
    strat_df = ds.load_info_dict()

    session = requests.Session()
    session.headers.update({'Accept': 'application/json'})

    update_status = []

    for _, row in strat_df.iterrows():
        name: str = str(row['name'])
        symbol: str = str(row['symbol'])
        endpoint_url: str = str(row['url'])
        resolution: str = '10m'

        params = {
            'a': symbol,
            's': unix_since,
            'u': unix_until,
            'api_key': gn_api_value,
            'i': resolution
        }

        try:
            resp = session.get(endpoint_url, params=params, timeout=60)
            resp.raise_for_status()
        except requests.RequestException as e:
            logger.error(f'HTTP error for {symbol} at {endpoint_url}: {e}')
            update_status.append(False)  # ✅ 記錄失敗
            continue

        text = resp.text.strip()

        try:
            df_raw = pd.read_json(StringIO(text))
            if df_raw.empty or 't' not in df_raw.columns:
                logger.warning(f'Empty dataframe or missing "t" column for {symbol}')
                update_status.append(False)  # ✅ 記錄失敗
                continue

            last_dt = df_raw['t'].iloc[-1]
            is_updated = last_dt >= unix_hr_start
            update_status.append(is_updated)  # ✅ 記錄狀態

            # ✅ 詳細日誌
            last_dt_str = datetime.fromtimestamp(last_dt, tz=timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
            hr_start_str = datetime.fromtimestamp(unix_hr_start, tz=timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
            logger.info(f'{name}: last_dt={last_dt_str}, hr_start={hr_start_str}, updated={is_updated}')

        except Exception as e:
            logger.error(f'Error processing data for {symbol}: {e}')
            update_status.append(False)  # ✅ 記錄失敗
            continue

    # ✅ 只有當 ALL symbols 都更新時才返回 True
    all_updated = all(update_status) if update_status else False

    logger.info(f'Update status: {sum(update_status)}/{len(update_status)} endpoint updated')
    logger.info(f'gn_10m_status() returning: {all_updated}')

    return all_updated


def scheduler(bet_size):

    start_time = datetime.now(timezone.utc)
    start_time_str = start_time.strftime("%Y-%m-%d %H:%M:%S")
    logger.info(f'Starting algo_seq at (UTC) {start_time_str}')

    # 1. Load strategy configuration
    ds = DataSourceConfig()
    ds.create_folder()
    strat_df = ds.load_info_dict()
    logger.info(f'Loaded #{len(strat_df)} rows of strategy configuration')

    # 2. Build request / data frame
    dcs = DataCenterSrv(strat_df)
    dcs.create_df()
    logger.info('Data cleaning and update data complete')

    # 3. Collect market data
    algo = AlgoStrategy(strat_df)
    algo.data_collect()
    logger.info('Data collection completed')

    # 4. Generate trading signals
    gen_signal = CreateSignal(strat_df)
    signal_df = gen_signal.split_sub()
    logger.info(f'Generated {len(signal_df)} signals')

    # 5. Execute signals with per-symbol bet sizes
    signal_exec = SignalExecution(signal_df, BET_SIZE)
    signal_exec.create_market_order()
    logger.info(f'Executed market orders with bet_size mapping: {BET_SIZE}')

    end_time = datetime.now(timezone.utc)
    duration = (end_time - start_time).total_seconds()
    end_time_str = end_time.strftime("%Y-%m-%d %H:%M:%S")
    logger.info(f'algo_seq finished at (UTC) {end_time_str} (duration: {round(duration, 1)} sec)')


if __name__ == '__main__':
    BET_SIZE = {'BTC': 0.001, 'ETH': 0.01}
    each_min: str = ':30'

    logger.info('Starting unified scheduler + algo program')


    def check_n_run():
        max_attempts = 5
        scheduler_executed = False

        for attempt in range(max_attempts):
            xx_min = 30 + (attempt * 5)  # :30, :35, :40, :45, :50

            # Wait until the target minute if we're not there yet
            while True:
                current_min = datetime.now().minute
                if current_min == xx_min:
                    break
                # If we've passed this minute, skip to the check
                if current_min > xx_min:
                    break
                time.sleep(1)

            logger.info(f'Verify gn_10m_status at minute :{xx_min:02d} (attempt {attempt + 1}/{max_attempts})')

            if gn_10m_status():
                logger.info(f'Verify gn_10m_status() all (True) at minute :{xx_min:02d}, running scheduler')
                scheduler(BET_SIZE)
                scheduler_executed = True
                break
            else:
                logger.info(f'Verify gn_10m_status() all (False) at minute :{xx_min:02d}')

        # Max attempts reached without success
        if not scheduler_executed:
            logger.warning(f'Max attempts ({max_attempts}) reached, gn_10m_status() never returned True')
            logger.warning(f'Skipping scheduler execution this hour, will retry at next hour :30')


    schedule.every().hour.at(each_min).do(check_n_run)
    try:
        while True:
            schedule.run_pending()
            time.sleep(1)
    except KeyboardInterrupt:
        logger.warning('KeyboardInterrupt received; program terminated.')